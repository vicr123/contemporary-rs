use crate::config::I18N_CONFIG;
use contemporary_i18n_core::load;
use proc_macro::TokenStream;
use quote::quote;
use std::env;
use std::path::Path;

macro_rules! extract_plural_rule {
    ($items:ident, $n:ident) => {
        $items
            .get(stringify!($n))
            .map(|str| {
                quote! {
                    $n: #str,
                }
            })
            .unwrap_or(quote! {
                $n: None,
            })
    };
}

pub fn tr_load(_body: TokenStream) -> TokenStream {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("Failed to get CARGO_MANIFEST_DIR");

    let config = &*I18N_CONFIG;
    let catalog_files = config.i18n.catalog_files(Path::new(&manifest_dir));

    let mut language_map = Vec::new();
    for file in catalog_files {
        let mut strings = Vec::new();

        let language = file.file_stem().unwrap().to_str();
        let decoded_file = load::translation(&file).unwrap();
        for (key, entry) in decoded_file {
            strings.push(match entry {
                load::TranslationEntry::Entry(string) => quote! {
                    #key => Some(I18nEntry::Entry(I18nStringEntry {
                        entry: #string.to_string(),
                    }))
                },
                load::TranslationEntry::PluralEntry(items) => {
                    let other = items.get("other").unwrap();

                    let zero = extract_plural_rule!(items, zero);
                    let one = extract_plural_rule!(items, one);
                    let two = extract_plural_rule!(items, two);
                    let few = extract_plural_rule!(items, few);
                    let many = extract_plural_rule!(items, many);

                    quote! {
                        #key => Some(I18nEntry::Entry(I18nPluralStringEntry {
                            locale: language,
                            zero: #zero,
                            one: #one,
                            two: #two,
                            few: #few,
                            many: #many,
                            other: #other
                        }))
                    }
                }
            })
        }

        language_map.push(quote! {
            #language => match id {
                #( #strings, )*
                _ => None,
            },
        });
    }

    quote! {
        {
            use contemporary_i18n::{I18nEntry, I18nSource, I18nStringEntry, LanguageRange, Locale};

            struct AutogeneratedSource;

            impl AutogeneratedSource {
                fn decompose_language_range(&self, language_range: LanguageRange) -> Vec<String> {
                    let mut result = Vec::new();
                    let range_string = language_range.to_string();
                    let segments: Vec<&str> = range_string.split('-').collect();

                    for i in (1..=segments.len()).rev() {
                        result.push(segments[..i].join("-"));
                    }

                    result
                }
            }

            impl I18nSource for AutogeneratedSource {
                fn lookup(&self, locale: &Locale, id: &str) -> Option<I18nEntry> {
                    for range in locale.tags_for("messages") {
                        for language in self.decompose_language_range(range) {
                            let entry = match language.as_str() {
                                #( #language_map )*
                                _ => None
                            };
                            if entry.is_some() {
                                return entry;
                            }
                        }
                    }

                    None
                }
            }

            AutogeneratedSource {}
        }
    }
    .into()
}
