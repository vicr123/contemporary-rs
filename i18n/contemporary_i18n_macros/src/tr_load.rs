use crate::config::{CURRENT_CRATE, I18N_CONFIG};
use contemporary_i18n_core::load;
use proc_macro::TokenStream;
use quote::quote;
use std::env;
use std::path::Path;

macro_rules! extract_plural_rule {
    ($items:ident, $n:ident) => {
        $items
            .get(stringify!($n))
            .map(|str| {
                quote! {
                    $n: Some(I18nString::Borrowed(#str))
                }
            })
            .unwrap_or(quote! {
                $n: None
            })
    };
}

pub fn tr_load(_body: TokenStream) -> TokenStream {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("Failed to get CARGO_MANIFEST_DIR");

    let config = &*I18N_CONFIG;
    let default_language = &config.i18n.default_language;
    let catalog_files = config.i18n.catalog_files(Path::new(&manifest_dir));

    let mut language_map = Vec::new();
    for file in catalog_files {
        let mut strings = Vec::new();

        let language = file.file_stem().unwrap().to_str().unwrap();
        let decoded_file = load::translation(&file).unwrap();
        for (key, entry) in decoded_file {
            strings.push(match entry {
                load::TranslationEntry::Entry(string) => quote! {
                    #key => I18nEntry::Entry(I18nStringEntry {
                        entry: I18nString::Borrowed(#string),
                    })
                },
                load::TranslationEntry::PluralEntry(items) => {
                    let other = items.get("other");
                    let Some(other) = other else {
                        panic!(
                            "Translation key {key} for language {language} has plural entry \
                            without other",
                        )
                        // return ParseBuffer::error(format!(
                        //     "Translation key {} has plural entry without other",
                        //     variable.name.to_string(),
                        //     input.translation_id.value()
                        // ))
                        // .to_compile_error()
                        // .into();
                    };

                    let zero = extract_plural_rule!(items, zero);
                    let one = extract_plural_rule!(items, one);
                    let two = extract_plural_rule!(items, two);
                    let few = extract_plural_rule!(items, few);
                    let many = extract_plural_rule!(items, many);

                    quote! {
                        #key => I18nEntry::PluralEntry(I18nPluralStringEntry {
                            locale: I18nString::Borrowed(#language),
                            #zero,
                            #one,
                            #two,
                            #few,
                            #many,
                            other: I18nString::Borrowed(#other)
                        })
                    }
                }
            })
        }

        language_map.push(quote! {
            #language => phf::phf_map! {
                #( #strings, )*
            },
        });
    }

    let current_crate = &*CURRENT_CRATE;

    quote! {
        {
            use contemporary_i18n::{I18nEntry, I18nSource, I18nStringEntry, I18nPluralStringEntry, I18nString, Locale, phf};
            use std::iter::once;

            struct AutogeneratedSource {
                default_language: String
            };

            impl I18nSource for AutogeneratedSource {
                fn lookup(&self, locale: &Locale, id: &str, lookup_crate: &str) -> Option<&I18nEntry> {

                    if lookup_crate != #current_crate {
                        return None;
                    }

                    for language in locale.messages.iter().chain(once(&self.default_language)) {
                        static STRING_MAP: phf::Map<&'static str, phf::Map<&'static str, I18nEntry>> = phf::phf_map! {
                            #( #language_map )*
                        };

                        let entry = STRING_MAP.get(language.as_str()).map(|v| v.get(id)).flatten();

                        if entry.is_some() {
                            return entry;
                        }
                    }

                    None
                }
            }

            AutogeneratedSource {
                default_language: #default_language.to_string()
            }
        }
    }
    .into()
}
