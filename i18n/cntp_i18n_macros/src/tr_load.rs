use crate::config::{CURRENT_CRATE, I18N_CONFIG};
use crate::parse_raw_string::I18nStringPartExtensions;
use crate::translation_file_cache::{ParsedTranslationEntry, TRANSLATION_FILE_CACHE};
use proc_macro::TokenStream;
use quote::quote;

macro_rules! extract_plural_rule {
    ($items:ident, $key:ident, $n:ident) => {
        $items
            .get(stringify!($n))
            .map(|str| {
                let matched_string = str
                    .iter()
                    .map(|f| f.calculate_string_part($key).to_tokens())
                    .collect::<Vec<_>>();
                quote! {
                    $n: Some(&[#( #matched_string, )*])
                }
            })
            .unwrap_or(quote! {
                $n: None
            })
    };
}

/// Generates an `I18nSource` containing the strings from the translation files located in the
/// configured translation directory.
///
/// By default, when strings are loaded (at compile time), the line endings are automatically
/// changed to match the compiled platform's line endings. If you wish to disable this behaviour,
/// set `match_line_endings` to false in your i18n configuration.
pub fn tr_load(_body: TokenStream) -> TokenStream {
    let config = &*I18N_CONFIG;
    let default_language = &config.i18n.default_language;

    let mut language_map = Vec::new();
    for (language, decoded_file) in TRANSLATION_FILE_CACHE.iter() {
        let mut strings = Vec::new();

        for (key, entry) in decoded_file {
            if let Some(token_stream) = match entry {
                ParsedTranslationEntry::Entry(string) => {
                    if string.is_empty() {
                        None
                    } else {
                        let matched_string = string
                            .iter()
                            .map(|f| f.calculate_string_part(key).to_tokens())
                            .collect::<Vec<_>>();
                        Some(quote! {
                            #key => I18nEntry::Entry(&[#( #matched_string, )*])
                        })
                    }
                }
                ParsedTranslationEntry::PluralEntry(items) => {
                    if items.iter().all(|(_key, value)| value.is_empty()) {
                        None
                    } else {
                        let other = items.get("other");
                        let Some(other) = other else {
                            panic!(
                                "Translation key {key} for language {language} has plural entry \
                                without other",
                            )
                            // return ParseBuffer::error(format!(
                            //     "Translation key {} has plural entry without other",
                            //     variable.name.to_string(),
                            //     input.translation_id.value()
                            // ))
                            // .to_compile_error()
                            // .into();
                        };

                        let matched_other = other
                            .iter()
                            .map(|f| f.calculate_string_part(key).to_tokens())
                            .collect::<Vec<_>>();

                        let zero = extract_plural_rule!(items, key, zero);
                        let one = extract_plural_rule!(items, key, one);
                        let two = extract_plural_rule!(items, key, two);
                        let few = extract_plural_rule!(items, key, few);
                        let many = extract_plural_rule!(items, key, many);

                        Some(quote! {
                            #key => I18nEntry::PluralEntry(I18nPluralStringEntry {
                                locale: I18nString::Borrowed(#language),
                                #zero,
                                #one,
                                #two,
                                #few,
                                #many,
                                other: &[#( #matched_other, )*]
                            })
                        })
                    }
                }
            } {
                strings.push(token_stream);
            }
        }

        language_map.push(quote! {
            #language => phf::phf_map! {
                #( #strings, )*
            },
        });
    }

    let current_crate = &*CURRENT_CRATE;

    quote! {
        {
            use cntp_i18n::{I18nEntry, I18nSource, I18nStringEntry, I18nPluralStringEntry, I18nString, Locale, phf};
            use std::iter::once;

            struct AutogeneratedSource {
                default_language: &'static str
            };

            impl I18nSource for AutogeneratedSource {
                fn lookup(&self, locale: &Locale, id: &str, lookup_crate: &str) -> Option<&I18nEntry> {

                    if lookup_crate != #current_crate {
                        return None;
                    }

                    for language in locale.messages.iter().map(|s| s.as_str()).chain(once(self.default_language)) {
                        static STRING_MAP: phf::Map<&'static str, phf::Map<&'static str, I18nEntry>> = phf::phf_map! {
                            #( #language_map )*
                        };

                        let entry = STRING_MAP.get(language).map(|v| v.get(id)).flatten();

                        if entry.is_some() {
                            return entry;
                        }
                    }

                    None
                }
            }

            AutogeneratedSource {
                default_language: #default_language
            }
        }
    }
    .into()
}
