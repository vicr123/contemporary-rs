use crate::config::{CURRENT_CRATE, I18N_CONFIG};
use cntp_i18n_core::load;
use proc_macro::TokenStream;
use quote::quote;
use std::env;
use std::path::Path;

macro_rules! extract_plural_rule {
    ($items:ident, $n:ident) => {
        $items
            .get(stringify!($n))
            .map(|str| {
                let string = match_line_endings(str);
                quote! {
                    $n: Some(I18nString::Borrowed(#string))
                }
            })
            .unwrap_or(quote! {
                $n: None
            })
    };
}

fn match_line_endings(string: &str) -> proc_macro2::TokenStream {
    if true {
        let windows_string = string.replace("\n", "\r\n");
        let unix_string = string.replace("\r\n", "\n");

        return quote! {
            {
                #[cfg(target_os = "windows")]
                {#windows_string}

                #[cfg(not(target_os = "windows"))]
                {#unix_string}
            }
        };
    }

    quote! { #string }
}

/// Generates an `I18nSource` containing the strings from the translation files located in the
/// configured translation directory.
///
/// By default, when strings are loaded (at compile time), the line endings are automatically
/// changed to match the compiled platform's line endings. If you wish to disable this behaviour,
/// set `match_line_endings` to false in your i18n configuration.
pub fn tr_load(_body: TokenStream) -> TokenStream {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("Failed to get CARGO_MANIFEST_DIR");

    let config = &*I18N_CONFIG;
    let default_language = &config.i18n.default_language;
    let catalog_files = config.i18n.catalog_files(Path::new(&manifest_dir));

    let mut language_map = Vec::new();
    for file in catalog_files {
        let mut strings = Vec::new();

        let language = file.file_stem().unwrap().to_str().unwrap();
        let decoded_file = load::translation(&file).unwrap();
        for (key, entry) in decoded_file {
            if let Some(token_stream) = match entry {
                load::TranslationEntry::Entry(string) => {
                    if string.is_empty() {
                        None
                    } else {
                        let matched_string = match_line_endings(string.as_str());
                        Some(quote! {
                            #key => I18nEntry::Entry(I18nStringEntry {
                                entry: I18nString::Borrowed(#matched_string),
                            })
                        })
                    }
                }
                load::TranslationEntry::PluralEntry(items) => {
                    if items.iter().all(|(key, value)| value.is_empty()) {
                        None
                    } else {
                        let other = items.get("other");
                        let Some(other) = other else {
                            panic!(
                                "Translation key {key} for language {language} has plural entry \
                            without other",
                            )
                            // return ParseBuffer::error(format!(
                            //     "Translation key {} has plural entry without other",
                            //     variable.name.to_string(),
                            //     input.translation_id.value()
                            // ))
                            // .to_compile_error()
                            // .into();
                        };

                        let zero = extract_plural_rule!(items, zero);
                        let one = extract_plural_rule!(items, one);
                        let two = extract_plural_rule!(items, two);
                        let few = extract_plural_rule!(items, few);
                        let many = extract_plural_rule!(items, many);

                        Some(quote! {
                            #key => I18nEntry::PluralEntry(I18nPluralStringEntry {
                                locale: I18nString::Borrowed(#language),
                                #zero,
                                #one,
                                #two,
                                #few,
                                #many,
                                other: I18nString::Borrowed(#other)
                            })
                        })
                    }
                }
            } {
                strings.push(token_stream);
            }
        }

        language_map.push(quote! {
            #language => phf::phf_map! {
                #( #strings, )*
            },
        });
    }

    let current_crate = &*CURRENT_CRATE;

    quote! {
        {
            use cntp_i18n::{I18nEntry, I18nSource, I18nStringEntry, I18nPluralStringEntry, I18nString, Locale, phf};
            use std::iter::once;

            struct AutogeneratedSource {
                default_language: String
            };

            impl I18nSource for AutogeneratedSource {
                fn lookup(&self, locale: &Locale, id: &str, lookup_crate: &str) -> Option<&I18nEntry> {

                    if lookup_crate != #current_crate {
                        return None;
                    }

                    for language in locale.messages.iter().chain(once(&self.default_language)) {
                        static STRING_MAP: phf::Map<&'static str, phf::Map<&'static str, I18nEntry>> = phf::phf_map! {
                            #( #language_map )*
                        };

                        let entry = STRING_MAP.get(language.as_str()).map(|v| v.get(id)).flatten();

                        if entry.is_some() {
                            return entry;
                        }
                    }

                    None
                }
            }

            AutogeneratedSource {
                default_language: #default_language.to_string()
            }
        }
    }
    .into()
}
